# Python Object Oriented Programming
Object-Oriented Programming (OOP) is a programming paradigm that is widely used in Python and many other programming languages. OOP is based on the concept of "objects," which are instances of classes, and it provides a way to structure and organize code in a more modular and reusable manner. In Python, OOP is a fundamental concept, and it allows you to create and work with classes and objects. Here are the key aspects of Python Object-Oriented Programming:

![image](https://github.com/ARUNRGAGILITY/python_foundations_course/assets/96728746/5ebb8fa2-8036-4c1d-a505-9d995381478f)

![image](https://github.com/ARUNRGAGILITY/python_foundations_course/assets/96728746/bac25860-c4ef-42fd-b8da-d080bce8b0d1)

### Classes and Objects

- **Class**: A class is a blueprint or template for creating objects. It defines the attributes (data members) and methods (functions) that the objects of the class will have. In Python, a class is defined using the `class` keyword.

    ```python
    class MyClass:
        def __init__(self, attribute1, attribute2):
            self.attribute1 = attribute1
            self.attribute2 = attribute2

        def my_method(self):
            return self.attribute1 + self.attribute2
    ```

- **Object**: An object is an instance of a class. It represents a specific entity or data structure created based on the class's blueprint. Objects have their own unique set of attributes and can invoke the methods defined in their class.

    ```python
    obj = MyClass(10, 20)
    result = obj.my_method()
    ```

### Encapsulation

- **Encapsulation**: Encapsulation is the principle of bundling data (attributes) and the methods (functions) that operate on that data into a single unit called a class. It helps in hiding the internal details of how a class works and provides an interface for interacting with objects.

### Inheritance

- **Inheritance**: Inheritance is a mechanism that allows a class (subclass or derived class) to inherit attributes and methods from another class (superclass or base class). It promotes code reuse and the creation of a hierarchy of classes.

    ```python
    class ParentClass:
        def parent_method(self):
            print("Parent method")

    class ChildClass(ParentClass):
        def child_method(self):
            print("Child method")

    obj = ChildClass()
    obj.parent_method()  # Inherited from ParentClass
    ```

### Polymorphism

- **Polymorphism**: Polymorphism allows objects of different classes to be treated as objects of a common superclass. It enables you to define methods with the same name but different implementations in different classes.

    ```python
    class Dog:
        def speak(self):
            return "Woof!"

    class Cat:
        def speak(self):
            return "Meow!"

    def animal_sound(animal):
        return animal.speak()

    dog = Dog()
    cat = Cat()
    print(animal_sound(dog))  # "Woof!"
    print(animal_sound(cat))  # "Meow!"
    ```

### Abstraction

- **Abstraction**: Abstraction is the process of simplifying complex reality by modeling classes based on essential properties and behaviors while ignoring non-essential details. It focuses on what an object does rather than how it does it.

### Method Overriding

- **Method Overriding**: In Python, you can override (replace) a method defined in the superclass with a new implementation in the subclass. This allows you to customize the behavior of inherited methods.

    ```python
    class ParentClass:
        def greet(self):
            return "Hello from ParentClass"

    class ChildClass(ParentClass):
        def greet(self):
            return "Hello from ChildClass"

    obj = ChildClass()
    print(obj.greet())  # "Hello from ChildClass"
    ```

Python's support for OOP makes it a versatile and powerful language for modeling real-world entities and building complex software systems. It promotes code reusability, maintainability, and modularity, making it a popular choice for a wide range of applications.

## Python OOP 
![image](https://github.com/ARUNRGAGILITY/python_foundations_course/assets/96728746/de29ca79-6f8f-497e-8d3b-f3e3006ca185)
![image](https://github.com/ARUNRGAGILITY/python_foundations_course/assets/96728746/32988780-38e8-4290-93f3-207d0aac02bc)
![image](https://github.com/ARUNRGAGILITY/python_foundations_course/assets/96728746/cb58debb-4639-4bd2-b6bd-cca49940d77f)


## Python OOP Inheritance

![image](https://github.com/ARUNRGAGILITY/python_foundations_course/assets/96728746/0f9d7f5b-2acc-4add-8a5f-68a8eb3dccf1)

## Inheritance example
![image](https://github.com/ARUNRGAGILITY/python_foundations_course/assets/96728746/573b5496-b3d1-40a3-8fb5-be67adc5e296)
    

## Types of Inheritance 
![image](https://github.com/ARUNRGAGILITY/python_foundations_course/assets/96728746/2da08b75-2c4c-4f6a-80ee-a1630ff1ba0d)

![image](https://github.com/ARUNRGAGILITY/python_foundations_course/assets/96728746/fe85b614-ca1e-4823-8648-7b6df48245da)

![image](https://github.com/ARUNRGAGILITY/python_foundations_course/assets/96728746/39a59931-ac61-4f77-8f9e-8ed1ee901ead)

## Polymorpism

![image](https://github.com/ARUNRGAGILITY/python_foundations_course/assets/96728746/31780b03-e88f-44d8-8a5f-16eeafaaafef)

## Abstraction 

![image](https://github.com/ARUNRGAGILITY/python_foundations_course/assets/96728746/f1a921c0-6db8-4fce-a40d-851a6674f072)

## Access Modifiers 

![image](https://github.com/ARUNRGAGILITY/python_foundations_course/assets/96728746/d0a34e1d-c0e3-440f-ab77-3a6e8ff1b94b)




## Python OOP Examples with Vehicles 
Let's create a series of Python classes representing vehicles, including a base class `Vehicle`, and subclasses `Car`, `Bike`, `Bus`, and `Truck`. We'll cover various Object-Oriented Programming (OOP) concepts such as inheritance, polymorphism, encapsulation, and abstraction.

### Base Class: Vehicle

We'll start with a base class `Vehicle` that contains common attributes and methods shared by all vehicles.

```python
class Vehicle:
    def __init__(self, make, model, year, color):
        self.make = make
        self.model = model
        self.year = year
        self.color = color

    def start_engine(self):
        print(f"{self.make} {self.model}'s engine started.")

    def stop_engine(self):
        print(f"{self.make} {self.model}'s engine stopped.")

    def honk(self):
        print(f"{self.make} {self.model} honked the horn.")
```

### Subclass: Car

We'll create a subclass `Car` that inherits from the `Vehicle` class. It will also have its own unique methods.

```python
class Car(Vehicle):
    def __init__(self, make, model, year, color, fuel_type):
        super().__init__(make, model, year, color)
        self.fuel_type = fuel_type

    def drive(self):
        print(f"{self.color} {self.make} {self.model} is driving.")

    def park(self):
        print(f"{self.color} {self.make} {self.model} is parked.")
```

### Subclass: Bike

Next, we'll create a subclass `Bike` that represents a bicycle. It inherits from the `Vehicle` class.

```python
class Bike(Vehicle):
    def __init__(self, make, model, year, color):
        super().__init__(make, model, year, color)

    def pedal(self):
        print(f"{self.color} {self.make} {self.model} is pedaling.")

    def stop(self):
        print(f"{self.color} {self.make} {self.model} stopped pedaling.")
```

### Subclass: Bus

We'll create a subclass `Bus` that represents a bus. It inherits from the `Vehicle` class.

```python
class Bus(Vehicle):
    def __init__(self, make, model, year, color, capacity):
        super().__init__(make, model, year, color)
        self.capacity = capacity

    def open_doors(self):
        print(f"{self.color} {self.make} {self.model} opened its doors for passengers.")

    def close_doors(self):
        print(f"{self.color} {self.make} {self.model} closed its doors.")
```

### Subclass: Truck

Lastly, we'll create a subclass `Truck` that represents a truck. It inherits from the `Vehicle` class.

```python
class Truck(Vehicle):
    def __init__(self, make, model, year, color, payload_capacity):
        super().__init__(make, model, year, color)
        self.payload_capacity = payload_capacity

    def load_payload(self):
        print(f"{self.color} {self.make} {self.model} is loading its payload.")

    def unload_payload(self):
        print(f"{self.color} {self.make} {self.model} is unloading its payload.")
```

### Putting It All Together

Now, let's create instances of these classes and demonstrate various OOP concepts:

```python
# Creating instances of different vehicles
car1 = Car("Toyota", "Camry", 2022, "Blue", "Gasoline")
bike1 = Bike("Trek", "Mountain Bike", 2021, "Red")
bus1 = Bus("Volvo", "V70", 2020, "Yellow", 50)
truck1 = Truck("Ford", "F-150", 2019, "White", "2 tons")

# Demonstrating methods and attributes
car1.start_engine()
bike1.pedal()
bus1.open_doors()
truck1.load_payload()

car1.drive()
bike1.stop()
bus1.close_doors()
truck1.unload_payload()

car1.honk()

# Polymorphism
vehicles = [car1, bike1, bus1, truck1]
for vehicle in vehicles:
    vehicle.start_engine()

# Encapsulation and Abstraction
car1._mileage = 10000  # Encapsulation (underscore indicates a protected attribute)
print(f"{car1.make} {car1.model}'s mileage: {car1._mileage}")

# Abstract method (not implemented here)
from abc import ABC, abstractmethod

class Vehicle(ABC):
    @abstractmethod
    def drive(self):
        pass
```

In this example, we've demonstrated inheritance, polymorphism, encapsulation, abstraction, and various OOP principles by creating and using different vehicle classes. Each class inherits attributes and methods from the `Vehicle` base class while also adding its own unique functionality.

