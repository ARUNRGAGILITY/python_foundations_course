# Python Sorting Algorithms

### 1. Bubble Sort
- **Purpose**: A simple comparison-based algorithm where each pair of adjacent elements is compared and swapped if they are in the wrong order. This process is repeated until the list is sorted.
- **Usage**: Due to its simplicity, it is often taught for educational purposes. However, it is inefficient for large lists.
- **Example**:
    ```python
    def bubble_sort(arr):
        n = len(arr)
        for i in range(n):
            for j in range(0, n-i-1):
                if arr[j] > arr[j+1]:
                    arr[j], arr[j+1] = arr[j+1], arr[j]

    arr = [64, 34, 25, 12, 22, 11, 90]
    bubble_sort(arr)
    print("Sorted array is:", arr)
    ```

### 2. Insertion Sort
- **Purpose**: Builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms like quicksort, heapsort, or merge sort.
- **Usage**: Useful for small data sets or nearly sorted lists.
- **Example**:
    ```python
    def insertion_sort(arr):
        for i in range(1, len(arr)):
            key = arr[i]
            j = i-1
            while j >=0 and key < arr[j]:
                arr[j+1] = arr[j]
                j -= 1
            arr[j+1] = key

    arr = [12, 11, 13, 5, 6]
    insertion_sort(arr)
    print("Sorted array is:", arr)
    ```

### 3. Merge Sort
- **Purpose**: An efficient, stable, comparison-based, divide and conquer sorting algorithm. Most implementations produce a stable sort.
- **Usage**: Used in various real-world applications due to its efficiency and the fact it's a stable sort (i.e., maintains the relative order of equal elements).
- **Example**:
    ```python
    def merge_sort(arr):
        if len(arr) > 1:
            mid = len(arr) // 2
            L = arr[:mid]
            R = arr[mid:]

            merge_sort(L)
            merge_sort(R)

            i = j = k = 0

            while i < len(L) and j < len(R):
                if L[i] < R[j]:
                    arr[k] = L[i]
                    i += 1
                else:
                    arr[k] = R[j]
                    j += 1
                k += 1

            while i < len(L):
                arr[k] = L[i]
                i += 1
                k += 1

            while j < len(R):
                arr[k] = R[j]
                j += 1
                k += 1

    arr = [12, 11, 13, 5, 6, 7]
    merge_sort(arr)
    print("Sorted array is:", arr)
    ```

### 4. Quick Sort
- **Purpose**: An efficient sorting algorithm, serving as a systematic method for placing the elements of an array in order. It's still a commonly used algorithm for sorting.
- **Usage**: Quick sort is often faster in practice than other O(n log n) algorithms. Also, quicksort can sort in-place.
- **Example**:
    ```python
    def quick_sort(arr):
        if len(arr) <= 1:
            return arr
        else:
            pivot = arr[0]
            less = [x for x in arr[1:] if x <= pivot]
            greater = [x for x in arr[1:] if x > pivot]
            return quick_sort(less) + [pivot] + quick_sort(greater)

    arr = [10, 7, 8, 9, 1, 5]
    sorted_arr = quick_sort(arr)
    print("Sorted array is:", sorted_arr)
    ```

### 5. Heap Sort
- **Purpose**: Heapsort is a comparison-based sorting technique based on a binary heap data structure. It's similar to selection sort where we first find the maximum element and place it at the end.
- **Usage**: Used when data is stored in a binary heap; the heap's properties allow us to efficiently find the largest (or smallest) element.
- **Example**:
    ```python
    import heapq

    def heap_sort(arr):
        heapq.heapify(arr)
        return [heapq.heappop(arr) for i in range(len(arr))]

    arr = [12, 11, 13, 5, 6,
